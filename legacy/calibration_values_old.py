import numpy as np
# As of April 11, 2021


def load_calibration(place):
    if place == 'Davis':  # place == 'Davis'
        return load_davis()
    else:
        return load_berkeley()


def load_davis():
    # All values in relation to a universal labeling scheme where, when facing the array from the front,
    # module 0 is the top left, module 3 is top right, module 4 is next row below module 0, etc. Module 15 is
    # the bottom right.
    # For PMTs, it is similar. Upper left is 0, upper right is 1, lower left is 2, lower right is 3

    calib = {}
    calib['pmts'] = np.array([[1, 3], [0, 2]])  # this is set when you plug in the cables
    # as looked at from the front how do the channels map to this 2x2 PMT grid i.e. where is the upper left,
    # upper right (first row), lower left, and lower right (second row) in terms of channels 1-4 on the first card
    calib['swapped'] = np.array([0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.])  # index 6 is swapped
    calib['swapped_pmts'] = np.array([[0, 3], [1, 2]])   # np.array([[1, 2], [0, 3]]) or prob np.array([[0, 3], [1, 2]])
    # Swapped means channels got swapped. This should not happen normally
    calib['pmt_gains'] = np.array([[1., 1., 1., 1.],  # 0
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 4
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 8
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 12
                                   [1., 1., 1., 1.],  # [1., 0.5, 1., 1.],
                                   [1., 0.5, 1., 1.],  # [1., 1., 1., 1.],
                                   [1., 1., 1., 1.]])

    calib['pmt_shifts'] = np.array([[0., 0., 0., 0.],  # 0
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 4
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 8
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 12
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.]])

    calib['module_gains'] = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
    calib['module_shifts'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

    # E(MeV) = A * log(ADC_value) - B
    calib['energy_a'] = np.array([2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.])
    calib['energy_b'] = np.array([17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5])

    # The proper way to do this
    calib['alpha_undistort'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0, 0., 0.])

    calib['crystal_x_edges'] = np.array([[0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 19.5, 25.5, 31, 39, 48, 57, 65, 70, 77, 82, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 13.5, 19.5, 26.4, 33, 39, 48, 58, 66, 73, 79, 86, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 19, 26, 32, 38, 47, 57, 64.5, 71, 78.5, 85.5, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])

    calib['crystal_y_edges'] = np.array([[0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 20, 27, 33, 40, 50, 58, 65, 72, 79, 83, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 18.5, 25.5, 31, 38, 47, 57, 65.5, 71.5, 79, 85.25, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 20, 27, 32.25, 39, 48, 57, 64.5, 70, 78, 85, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])

    return calib


def load_berkeley():
    # All values in relation to a universal labeling scheme where, when facing the array from the front,
    # module 0 is the top left, module 3 is top right, module 4 is next row below module 0, etc. Module 15 is
    # the bottom right.
    # For PMTs, it is similar. Upper left is 0, upper right is 1, lower left is 2, lower right is 3

    calib = {}
    calib['pmts'] = np.array([[1, 3], [0, 2]])  # this is set when you plug in the cables
    # as looked at from the front how do the channels map to this 2x2 PMT grid i.e. where is the upper left,
    # upper right (first row), lower left, and lower right (second row) in terms of channels 1-4 on the first card
    calib['swapped'] = np.array([0., 0., 0., 0., 0., 0., 0, 0., 0., 0., 0., 0., 0., 0., 0., 0.])
    calib['swapped_pmts'] = np.array([[0, 3], [1, 2]])  # np.array([[1, 2], [0, 3]]) or np.array([[0, 3], [1, 2]])
    # Swapped means channels got swapped. This should not happen normally
    calib['pmt_gains'] = np.array([[1., 1., 1., 1.],  # 0
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 4
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 8
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 12
                                   [1., 1., 1., 1.],
                                   [1., 0.5, 1., 1.],
                                   [1., 1., 1., 1.]])

    calib['pmt_shifts'] = np.array([[0., 0., 0., 0.],  # 0
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 4
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 8
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 12
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.]])

    calib['module_gains'] = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
    calib['module_shifts'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

    # E(MeV) = A * log(ADC_value) - B
    calib['energy_a'] = np.array([2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.])
    calib['energy_b'] = np.array([17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5])

    # The proper way to do this
    calib['alpha_undistort'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0, 0., 0.])

    calib['crystal_x_edges'] = np.array([[0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 19.5, 25.5, 31, 39, 48, 57, 65, 70, 77, 82, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 13.5, 19.5, 26.4, 33, 39, 48, 58, 66, 73, 79, 86, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 19, 26, 32, 38, 47, 57, 64.5, 71, 78.5, 85.5, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])

    calib['crystal_y_edges'] = np.array([[0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 20, 27, 33, 40, 50, 58, 65, 72, 79, 83, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 18.5, 25.5, 31, 38, 47, 57, 65.5, 71.5, 79, 85.25, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 20, 27, 32.25, 39, 48, 57, 64.5, 70, 78, 85, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])
    return calib