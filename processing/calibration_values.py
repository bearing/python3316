import numpy as np

# This is a placeholder for the moment. This should really just load from a text file. Used by one_module_processing


def load_calibration(place):
    if place == 'Davis':  # place == 'Davis'
        return load_davis()
    else:
        return load_berkeley()


def load_davis():
    # All values in relation to a universal labeling scheme where, when facing the array from the front,
    # module 0 is the top left, module 3 is top right, module 4 is next row below module 0, etc. Module 15 is
    # the bottom right.
    # For PMTs, it is similar. Upper left is 0, upper right is 1, lower left is 2, lower right is 3

    calib = {}
    calib['pmts'] = np.array([[1, 3], [0, 2]])  # this is set when you plug in the cables
    # as looked at from the front how do the channels map to this 2x2 PMT grid i.e. where is the upper left,
    # upper right (first row), lower left, and lower right (second row) in terms of channels 1-4 on the first card
    calib['swapped'] = np.array([0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.])  # index 6 is swapped
    calib['swapped_pmts'] = np.array([[0, 3], [1, 2]])   # np.array([[1, 2], [0, 3]]) or prob np.array([[0, 3], [1, 2]])
    # Swapped means channels got swapped. This should not happen normally
    calib['pmt_gains'] = np.array([[0.94, 1., 1., 0.97],  # 0
                                   [0.92, 1., 1.02, 1.],
                                   [0.94, 1., 1., 1.04],
                                   [1., 1., 1., 1.],
                                   [0.96, 1., 1., 1.],  # 4
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1.08, 1.11, 1., 1.18],  # 8
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 12
                                   [1., 1., 1., 1.],  # [1., 0.5, 1., 1.],
                                   [1., 0.5, 1., 1.],  # [1., 1., 1., 1.],
                                   [1., 1., 1., 1.]])

    calib['pmt_shifts'] = np.array([[0., 0., 0., 0.],  # 0
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 4
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 8
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 12
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.]])

    calib['module_gains'] = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
    calib['module_shifts'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

    # E(MeV) = A * log(ADC_value) - B
    calib['energy_a'] = np.array([2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.])
    calib['energy_b'] = np.array([17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5])

    # The proper way to do this
    calib['alpha_undistort'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0, 0., 0.])

    calib['crystal_x_edges'] = np.array([[0, 14.5, 21.5, 28, 33.5, 41, 50, 58.5, 65.5, 72, 79, 85.5, 100],  # 0
                                         [0, 15, 21.5, 28, 35, 41, 50, 57.5, 64.5, 70, 76, 82, 100],
                                         [0, 14, 20.5, 27, 33, 40, 49, 58, 65, 72, 78.5, 85, 100],  #2
                                         [0, 13.5, 20.5, 27, 32.5, 40, 49, 58.5, 65.5, 72.25, 79, 86, 100],
                                         [0, 14.5, 21, 27.5, 33.5, 41.5, 50, 58.5, 65.5, 72, 79, 85.5, 100],  # 4
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 13.5, 20, 27, 32.5, 41, 50, 59, 67, 73, 79, 85.5, 100],  # 8  (changed for Xchanged) - [0,14 ...]
                                         [0, 14, 21, 27, 31, 38, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 13.5, 19.5, 26.4, 33, 39, 48, 58, 66, 73, 79, 86, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 19, 26, 32, 38, 47, 57, 64.5, 71, 78.5, 85.5, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])

    calib['crystal_y_edges'] = np.array([[0, 14.5, 21, 27.5, 33.5, 41, 49.5, 58.5, 65.5, 72, 79, 86, 100],  # 0
                                         [0, 14.5, 20.5, 27, 32.5, 40, 47, 55, 62.5, 69, 75, 81.5, 100],  #
                                         [0, 14.5, 20, 27, 33.5, 40.5, 49.5, 58, 65, 72, 78.5, 85, 100],
                                         [0, 13.5, 20, 26.5, 33, 40, 49, 58, 65.5, 72, 79, 86, 100],
                                         [0, 14.5, 21, 27.5, 33.5, 41.5, 49.5, 58, 65.5, 72, 79, 85.5, 100],  # 4
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14.5, 19.5, 26, 32, 39.5, 48.5, 58, 65.5, 72, 78.5, 84.5, 100],  # 8 (changed for Ychanged)
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 18.5, 25.5, 31, 38, 47, 57, 65.5, 71.5, 79, 85.25, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 20, 27, 32.25, 39, 48, 57, 64.5, 70, 78, 85, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])

    return calib


def load_berkeley():
    # All values in relation to a universal labeling scheme where, when facing the array from the front,
    # module 0 is the top left, module 3 is top right, module 4 is next row below module 0, etc. Module 15 is
    # the bottom right.
    # For PMTs, it is similar. Upper left is 0, upper right is 1, lower left is 2, lower right is 3

    calib = {}
    calib['pmts'] = np.array([[1, 3], [0, 2]])  # this is set when you plug in the cables
    # as looked at from the front how do the channels map to this 2x2 PMT grid i.e. where is the upper left,
    # upper right (first row), lower left, and lower right (second row) in terms of channels 1-4 on the first card
    calib['swapped'] = np.array([0., 0., 0., 0., 0., 0., 0, 0., 0., 0., 0., 0., 0., 0., 0., 0.])
    calib['swapped_pmts'] = np.array([[0, 3], [1, 2]])  # np.array([[1, 2], [0, 3]]) or np.array([[0, 3], [1, 2]])
    # Swapped means channels got swapped. This should not happen normally
    calib['pmt_gains'] = np.array([[1., 1., 1., 1.],  # 0
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 4
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 8
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],
                                   [1., 1., 1., 1.],  # 12
                                   [1., 1., 1., 1.],
                                   [1., 0.5, 1., 1.],
                                   [1., 1., 1., 1.]])

    calib['pmt_shifts'] = np.array([[0., 0., 0., 0.],  # 0
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 4
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 8
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],  # 12
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.],
                                   [0., 0., 0., 0.]])

    calib['module_gains'] = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
    calib['module_shifts'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

    # E(MeV) = A * log(ADC_value) - B
    calib['energy_a'] = np.array([2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.])
    calib['energy_b'] = np.array([17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5])

    # The proper way to do this
    calib['alpha_undistort'] = np.array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0, 0., 0.])

    calib['crystal_x_edges'] = np.array([[0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 19.5, 25.5, 31, 39, 48, 57, 65, 70, 77, 82, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 13.5, 19.5, 26.4, 33, 39, 48, 58, 66, 73, 79, 86, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 19, 26, 32, 38, 47, 57, 64.5, 71, 78.5, 85.5, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])

    calib['crystal_y_edges'] = np.array([[0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 20, 27, 33, 40, 50, 58, 65, 72, 79, 83, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 18.5, 25.5, 31, 38, 47, 57, 65.5, 71.5, 79, 85.25, 100],  #
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 12.5, 20, 27, 32.25, 39, 48, 57, 64.5, 70, 78, 85, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100],
                                         [0, 14, 21, 27, 33, 40, 50, 58, 65, 72, 79, 86, 100]])
    return calib
